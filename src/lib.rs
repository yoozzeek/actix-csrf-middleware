use actix_http::{header::HeaderMap, StatusCode};
use actix_session::storage::CookieSessionStore;
#[cfg(feature = "actix-session")]
use actix_session::SessionExt;
use actix_utils::future::Either;
use actix_web::{
    body::{EitherBody, MessageBody},
    cookie::{Cookie, SameSite},
    dev::forward_ready,
    dev::{Service, ServiceRequest, ServiceResponse, Transform},
    http::{header, Method},
    web::BytesMut,
    Error, FromRequest, HttpMessage, HttpRequest, HttpResponse,
};
use base64::{engine::general_purpose::URL_SAFE_NO_PAD, Engine};
use futures_util::{
    future::{err, ok, Ready},
    ready,
    stream::StreamExt,
};
use hmac::{Hmac, Mac};
use log::{error, warn};
use pin_project_lite::pin_project;
use rand::RngCore;
use sha2::Sha256;
use std::ops::Deref;
use std::{
    collections::HashMap,
    future::Future,
    marker::PhantomData,
    pin::Pin,
    rc::Rc,
    task::{Context, Poll},
};
use subtle::ConstantTimeEq;

/// Cookie name or actix-session key used to store the token depending on enabled `session` feature.
pub const DEFAULT_CSRF_TOKEN_KEY: &str = "csrf-token";

/// Csrf token field name in `application/x-www-form-urlencoded` or `application/json` body.
/// `CsrfMiddleware` will try to extract a token from that field.
pub const DEFAULT_CSRF_TOKEN_FIELD: &str = "csrf_token";
pub const DEFAULT_CSRF_TOKEN_HEADER: &str = "X-CSRF-Token";

/// Key of user session created outside the middleware. It's cookie name or actix-session key
/// depending on enabled `session` feature and middleware core will extract value by this key
/// to use this unique session id in HMAC hashes. That's how `CsrfMiddleware` can be integrated
/// into existing applications that already have authorization logic.
pub const DEFAULT_SESSION_ID_KEY: &str = "id";

/// Cookie name of pre-session generated by `CsrfMiddleware` for allowed unauthorized routes
/// that need to mutate data when there's not authorized user yet. For example
/// in cases such as registration, login or newsletter subscription.
pub const CSRF_PRE_SESSION_KEY: &str = "pre-session";

/// Standard 256-bit encryption
const TOKEN_LEN: usize = 32; // 32 bytes -> 256 bits

type HmacSha256 = Hmac<Sha256>;

/// `CsrfPattern` allows use to configure `CsrfMiddleware` to read and store csrf tokens and
/// user sessions in client's browser cookie or in any persistent storage like Redis,
/// Postgres or in-memory that implements `actix_session::storage::SessionStore` trait if
/// you have enabled `session` feature.
#[derive(Clone, PartialEq)]
pub enum CsrfPattern {
    #[cfg(feature = "actix-session")]
    SynchronizerToken,
    DoubleSubmitCookie,
}

#[derive(Clone)]
pub struct CsrfDoubleSubmitCookie {
    pub http_only: bool,
    pub secure: bool,
    pub same_site: SameSite,
}

#[derive(Clone)]
pub struct CsrfMiddlewareConfig {
    pub pattern: CsrfPattern,
    pub manual_multipart: bool,
    pub session_id_cookie_name: String,
    pub token_cookie_name: String,
    pub token_form_field: String,
    pub token_header_name: String,
    pub token_cookie_config: Option<CsrfDoubleSubmitCookie>,
    pub secret_key: Vec<u8>,
    pub skip_for: Vec<String>,
    pub on_error: Rc<dyn Fn(&HttpRequest) -> HttpResponse>,
}

impl CsrfMiddlewareConfig {
    #[cfg(feature = "actix-session")]
    pub fn synchronizer_token(secret_key: &[u8]) -> Self {
        CsrfMiddlewareConfig {
            pattern: CsrfPattern::SynchronizerToken,
            session_id_cookie_name: DEFAULT_SESSION_ID_KEY.to_string(),
            token_cookie_name: DEFAULT_CSRF_TOKEN_KEY.into(),
            token_form_field: DEFAULT_CSRF_TOKEN_FIELD.into(),
            token_header_name: DEFAULT_CSRF_TOKEN_HEADER.into(),
            token_cookie_config: None,
            secret_key: secret_key.into(),
            skip_for: vec![],
            manual_multipart: false,
            on_error: Rc::new(|_| HttpResponse::BadRequest().body("Invalid CSRF token")),
        }
    }

    pub fn double_submit_cookie(secret_key: &[u8]) -> Self {
        CsrfMiddlewareConfig {
            pattern: CsrfPattern::DoubleSubmitCookie,
            session_id_cookie_name: DEFAULT_SESSION_ID_KEY.to_string(),
            token_cookie_name: DEFAULT_CSRF_TOKEN_KEY.into(),
            token_form_field: DEFAULT_CSRF_TOKEN_FIELD.into(),
            token_header_name: DEFAULT_CSRF_TOKEN_HEADER.into(),
            token_cookie_config: Some(CsrfDoubleSubmitCookie {
                http_only: false, // Should be false for double-submit cookie
                secure: true,
                same_site: SameSite::Strict,
            }),
            secret_key: secret_key.into(),
            skip_for: vec![],
            manual_multipart: false,
            on_error: Rc::new(|_| HttpResponse::BadRequest().body("Invalid CSRF token")),
        }
    }

    pub fn with_multipart(mut self, multipart: bool) -> Self {
        self.manual_multipart = multipart;
        self
    }

    pub fn with_token_cookie_config(mut self, config: CsrfDoubleSubmitCookie) -> Self {
        self.token_cookie_config = Some(config);
        self
    }

    pub fn with_on_error<F>(mut self, on_error: F) -> Self
    where
        F: Fn(&HttpRequest) -> HttpResponse + 'static,
    {
        self.on_error = Rc::new(on_error);
        self
    }

    pub fn with_skip_for(mut self, patches: Vec<String>) -> Self {
        self.skip_for = patches;
        self
    }
}

pub struct CsrfMiddleware {
    config: Rc<CsrfMiddlewareConfig>,
}

impl CsrfMiddleware {
    pub fn new(config: CsrfMiddlewareConfig) -> Self {
        Self {
            config: Rc::new(config),
        }
    }
}

impl<S, B> Transform<S, ServiceRequest> for CsrfMiddleware
where
    S: Service<ServiceRequest, Response = ServiceResponse<B>, Error = Error>,
    B: MessageBody,
{
    type Response = ServiceResponse<EitherBody<B>>;
    type Error = Error;
    type Transform = CsrfMiddlewareService<S>;
    type InitError = ();
    type Future = Ready<Result<Self::Transform, Self::InitError>>;

    fn new_transform(&self, service: S) -> Self::Future {
        ok(CsrfMiddlewareService {
            service: Rc::new(service),
            config: self.config.clone(),
        })
    }
}

pub struct CsrfMiddlewareService<S> {
    service: Rc<S>,
    config: Rc<CsrfMiddlewareConfig>,
}

impl<S> CsrfMiddlewareService<S> {
    fn get_session_id(&self, req: &ServiceRequest) -> (String, bool) {
        // Try to extract from session id cookie first,
        // if nothing found then check pre-session or create new one.
        if let Some(id) = req
            .cookie(&self.config.session_id_cookie_name)
            .map(|c| c.value().to_string())
        {
            (id, false)
        } else if let Some(id) = req
            .cookie(CSRF_PRE_SESSION_KEY)
            .map(|c| c.value().to_string())
        {
            (id, false)
        } else {
            // Generate pre-session id here
            (generate_random_token(), true)
        }
    }

    fn get_true_token(&self, req: &ServiceRequest, session_id: Option<&str>) -> (String, bool) {
        // If corresponding feature enabled then get token from persistent session storage
        if cfg!(feature = "actix-session") {
            let session = req.get_session();
            let found = session
                .get::<String>(&self.config.token_cookie_name)
                .ok()
                .flatten();

            return match found {
                Some(tok) => (tok, false),
                None => (generate_random_token(), true),
            };
        }

        // Otherwise, check for token in request cookies
        let token = {
            req.cookie(&self.config.token_cookie_name)
                .map(|c| c.value().to_string())
        };

        match token {
            Some(tok) => (tok, false),
            None => {
                let secret = self.config.secret_key.as_ref();
                let tok = generate_hmac_token(
                    session_id.expect("Session or pre-session id is passed"),
                    secret,
                );
                (tok.clone(), true)
            }
        }
    }

    fn should_skip_validation(&self, req: &ServiceRequest) -> bool {
        let req_path = req.path();
        self.config
            .skip_for
            .iter()
            .any(|prefix| req_path.starts_with(prefix))
    }
}

impl<S, B> Service<ServiceRequest> for CsrfMiddlewareService<S>
where
    S: Service<ServiceRequest, Response = ServiceResponse<B>, Error = Error>,
    B: MessageBody,
{
    type Response = ServiceResponse<EitherBody<B>>;
    type Error = Error;
    type Future = Either<CsrfTokenValidator<S, B>, Ready<Result<Self::Response, Self::Error>>>;

    forward_ready!(service);

    fn call(&self, req: ServiceRequest) -> Self::Future {
        if self.should_skip_validation(&req) {
            return Either::left(CsrfTokenValidator::SkippingValidation {
                fut: self.service.call(req),
                _phantom: PhantomData,
            });
        }

        // Get current token from cookie or actix-session or generate new one
        let (true_token, should_set_token, cookie_session): (String, bool, Option<(String, bool)>) =
            match self.config.pattern {
                CsrfPattern::DoubleSubmitCookie => {
                    let (session_id, should_set_session) = self.get_session_id(&req);
                    let (true_token, should_set_token) =
                        self.get_true_token(&req, Some(&session_id));
                    (
                        true_token,
                        should_set_token,
                        Some((session_id, should_set_session)),
                    )
                }
                #[cfg(feature = "actix-session")]
                CsrfPattern::SynchronizerToken => {
                    let (token, should_set_token) = self.get_true_token(&req, None);
                    (token, should_set_token, None)
                }
            };

        req.extensions_mut().insert(CsrfToken(true_token.clone()));

        let is_mutating = matches!(
            *req.method(),
            Method::POST | Method::PUT | Method::PATCH | Method::DELETE
        );

        let session_id = if let Some((session_id, should_set_session)) = cookie_session {
            if !should_set_session {
                None
            } else {
                Some(session_id.as_str())
            }
        } else {
            None
        };

        // Skip validation for read only requests, but csrf token still should be
        // added to the response when should_set_token flag is set to true.
        if !is_mutating {
            let token = if should_set_token {
                Some(true_token.as_bytes())
            } else {
                None
            };

            return Either::left(CsrfTokenValidator::ReadOnlyRequest {
                fut: self.service.call(req),
                config: self.config.clone(),
                set_token: token,
                set_session_id: session_id,
            });
        }

        // Otherwise, process mutating request with token
        // extraction from the body and future validation.

        // Handle multipart form data requests
        if let Some(ct) = req
            .headers()
            .get(header::CONTENT_TYPE)
            .and_then(|hv| hv.to_str().ok())
        {
            if ct.starts_with("multipart/form-data") {
                // Deny any multipart/form-data requests if
                // it isn't allowed explicitly by the consumer.
                if !self.config.manual_multipart {
                    let resp = HttpResponse::with_body(
                        StatusCode::BAD_REQUEST,
                        "Multipart form data is not enabled by csrf config".to_string(),
                    );

                    return Either::right(ok(req
                        .into_response(resp)
                        .map_into_boxed_body()
                        .map_into_right_body()));
                }

                // Otherwise, consumer reads body, extracts and
                // verifies csrf tokens manually in their handlers.
                return Either::left(CsrfTokenValidator::SkippingValidation {
                    fut: self.service.call(req),
                    _phantom: PhantomData,
                });
            }
        }

        // Try to extract csrf token from header
        let header_token = req
            .headers()
            .get(&self.config.token_header_name)
            .and_then(|hv| hv.to_str().ok())
            .map(|s| s.to_string());

        // Fastest and easiest way when token just received in headers
        if header_token.is_some() {
            return Either::left(CsrfTokenValidator::MutatingRequest {
                service: self.service.clone(),
                config: self.config.clone(),
                true_token: true_token.as_bytes(),
                client_token: header_token.unwrap().as_bytes(),
                session_id,
                req: Some(req),
            });
        }

        // For mutating requests without header token, read body first
        Either::left(CsrfTokenValidator::ReadingBody {
            req: Some(req),
            config: self.config.clone(),
            service: self.service.clone(),
            true_token: true_token.as_bytes(),
            session_id,
        })
    }
}

pin_project! {
    #[project = CsrfTokenValidatorProj]
    pub enum CsrfTokenValidator<'a, S, B>
    where
        S: Service<ServiceRequest>,
        B: MessageBody,
    {
        MutatingRequest {
            service: Rc<S>,
            config: Rc<CsrfMiddlewareConfig>,
            true_token: &'a [u8],
            client_token: &'a [u8],
            session_id: Option<&'a str>,
            req: Option<ServiceRequest>
        },
        ReadOnlyRequest {
            #[pin]
            fut: S::Future,
            config: Rc<CsrfMiddlewareConfig>,
            set_token: Option<&'a [u8]>,
            set_session_id: Option<&'a str>,
        },
        SkippingValidation {
            #[pin]
            fut: S::Future,
            _phantom: PhantomData<B>,
        },
        ReadingBody {
            service: Rc<S>,
            config: Rc<CsrfMiddlewareConfig>,
            req: Option<ServiceRequest>,
            true_token: &'a [u8],
            session_id: Option<&'a str>,
        },
    }
}

impl<S, B> Future for CsrfTokenValidator<'_, S, B>
where
    S: Service<ServiceRequest, Response = ServiceResponse<B>, Error = Error>,
    B: MessageBody,
{
    type Output = Result<ServiceResponse<EitherBody<B>>, Error>;

    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        match self.as_mut().project() {
            CsrfTokenValidatorProj::SkippingValidation { fut, _phantom } => {
                let resp = CsrfResponse {
                    fut,
                    config: None,
                    set_token: None,
                    _phantom: *_phantom,
                };

                resp.poll(cx)
            }
            CsrfTokenValidatorProj::ReadOnlyRequest {
                fut,
                config,
                set_token,
                set_session_id,
            } => {
                let resp = CsrfResponse {
                    fut,
                    config: Some(config.clone()),
                    set_token: *set_token,
                    _phantom: PhantomData,
                };

                resp.poll(cx)
            }
            CsrfTokenValidatorProj::MutatingRequest {
                service,
                config,
                true_token,
                client_token,
                session_id,
                req,
            } => {
                if let Some(req) = req.take() {
                    // Session id cannot be empty with DoubleSubmitCookie pattern
                    if cfg!(feature = "actix-session") && session_id.is_none() {
                        let resp = HttpResponse::with_body(
                            StatusCode::INTERNAL_SERVER_ERROR,
                            "Session id is empty in csrf token validator".to_string(),
                        );

                        return Poll::Ready(Ok(req
                            .into_response(resp)
                            .map_into_boxed_body()
                            .map_into_right_body()));
                    }

                    // Validate client token based on the pattern
                    let valid = match &config.pattern {
                        #[cfg(feature = "actix-session")]
                        CsrfPattern::SynchronizerToken => eq_tokens(true_token, client_token),
                        CsrfPattern::DoubleSubmitCookie => {
                            validate_hmac_token(
                                session_id.expect("session id cannot be empty is hmac validation"),
                                client_token,
                                b"",
                            )
                            .unwrap_or_else(|err| {
                                // TODO Handle validation errors
                                false
                            })
                        }
                    };

                    if !valid {
                        let resp = HttpResponse::BadRequest().body("Invalid CSRF token");
                        return Poll::Ready(Ok(req
                            .into_response(resp)
                            .map_into_boxed_body()
                            .map_into_right_body()));
                    }

                    // Generate new token based on configured pattern
                    let new_token = match &config.pattern {
                        #[cfg(feature = "actix-session")]
                        CsrfPattern::SynchronizerToken => generate_random_token(),
                        CsrfPattern::DoubleSubmitCookie => generate_hmac_token(
                            session_id.expect("session id cannot be empty is hmac validation"),
                            config.secret_key.as_ref(),
                        ),
                    };

                    let resp = CsrfResponse {
                        fut: service.call(req),
                        config: Some(config.clone()),
                        set_token: Some(new_token.as_bytes()),
                        _phantom: PhantomData,
                    };

                    resp.poll(cx)
                }
            }
            CsrfTokenValidatorProj::ReadingBody {
                service,
                config,
                req,
                true_token,
                session_id,
            } => {
                if let Some(mut request) = req.take() {
                    let mut body_bytes = BytesMut::new();
                    let mut payload = request.take_payload();

                    while let Some(chunk_result) = ready!(payload.poll_next_unpin(cx)) {
                        match chunk_result {
                            Ok(bytes) => body_bytes.extend_from_slice(&bytes),
                            Err(e) => {
                                return Poll::Ready(Err(actix_web::error::ErrorBadRequest(e)));
                            }
                        }
                    }

                    // Try to extract token from body
                    let client_token = match sync_read_token_from_body(
                        request.headers(),
                        &body_bytes,
                        &config.token_form_field,
                    ) {
                        Some(token) => token.as_bytes(),
                        None => {
                            let res = HttpResponse::BadRequest().body("CSRF token is required");
                            return Poll::Ready(Ok(request
                                .into_response(res)
                                .map_into_boxed_body()
                                .map_into_right_body()));
                        }
                    };

                    // Restore the body for the next handler
                    request.set_payload(actix_web::dev::Payload::from(body_bytes.freeze()));

                    self.set(CsrfTokenValidator::MutatingRequest {
                        service: service.clone(),
                        config: config.clone(),
                        true_token,
                        client_token,
                        session_id: *session_id,
                        req,
                    });

                    cx.waker().wake_by_ref(); // wake for the next pool
                    Poll::Pending
                } else {
                    error!("request already taken in csrf validator's state machine");

                    Poll::Ready(Err(actix_web::error::ErrorInternalServerError(
                        "Request was already taken",
                    )))
                }
            }
        }
    }
}

fn sync_read_token_from_body(
    headers: &HeaderMap,
    body: &[u8],
    token_field: &str,
) -> Option<String> {
    if let Some(ct) = headers.get(header::CONTENT_TYPE) {
        if let Ok(ct) = ct.to_str() {
            if ct.starts_with("application/json") {
                if let Ok(json) = serde_json::from_slice::<serde_json::Value>(body) {
                    return json
                        .get(token_field)
                        .and_then(|v| v.as_str().map(String::from));
                }
            } else if ct.starts_with("application/x-www-form-urlencoded") {
                if let Ok(form) = serde_urlencoded::from_bytes::<HashMap<String, String>>(body) {
                    return form.get(token_field).cloned();
                }
            } else {
                warn!("unsupported request content type, unable to extract and verify csrf token");
            }
        }
    }
    None
}

pin_project! {
    pub struct CsrfResponse<'a, S, B>
    where
        S: Service<ServiceRequest>,
        B: MessageBody,
    {
        #[pin]
        fut: S::Future,
        config: Option<Rc<CsrfMiddlewareConfig>>,
        set_token: Option<&'a [u8]>,
        _phantom: PhantomData<B>,
    }
}

impl<S, B> Future for CsrfResponse<'_, S, B>
where
    B: MessageBody,
    S: Service<ServiceRequest, Response = ServiceResponse<B>, Error = Error>,
{
    type Output = Result<ServiceResponse<EitherBody<B>>, Error>;

    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        let this = self.as_mut().project();
        match ready!(this.fut.poll(cx)) {
            Ok(mut resp) => {
                let config = match &this.config {
                    Some(config) => config,
                    None => {
                        let res = HttpResponse::InternalServerError()
                            .body("An empty csrf middleware config passed into csrf response");

                        error!("unable to extract csrf middleware config in csrf response");
                        return Poll::Ready(Ok(resp
                            .into_response(res)
                            .map_into_boxed_body()
                            .map_into_right_body()));
                    }
                };

                // Based on configured pattern, set a new token or rotate
                // the old one for the service response if pattern is passed.
                if let Some(token_bytes) = *this.set_token {
                    let new_token = str::from_utf8(token_bytes)?;
                    match config.pattern {
                        #[cfg(feature = "actix-session")]
                        CsrfPattern::SynchronizerToken => {
                            // Set a new token into actix session
                            match resp
                                .request()
                                .get_session()
                                .insert(&config.token_cookie_name, new_token)
                            {
                                Ok(()) => {}
                                Err(e) => {
                                    let res = HttpResponse::with_body(
                                        StatusCode::INTERNAL_SERVER_ERROR,
                                        "Failed to insert CSRF token into session".to_string(),
                                    );

                                    error!(
                                            "unable to set a csrf token with actix session in csrf response: {:?}",
                                            e
                                        );
                                    return Poll::Ready(Ok(resp
                                        .into_response(res)
                                        .map_into_boxed_body()
                                        .map_into_right_body()));
                                }
                            }
                        }
                        CsrfPattern::DoubleSubmitCookie => {
                            let cookie_config = match &config.token_cookie_config {
                                Some(config) => config,
                                None => {
                                    let res = HttpResponse::InternalServerError().body(
                                        "An empty csrf cookie config passed into csrf response",
                                    );

                                    error!(
                                        "unable to extract token_cookie_config in csrf response"
                                    );
                                    return Poll::Ready(Ok(resp
                                        .into_response(res)
                                        .map_into_boxed_body()
                                        .map_into_right_body()));
                                }
                            };

                            let new_token_cookie =
                                Cookie::build(&config.token_cookie_name, new_token)
                                    .http_only(cookie_config.http_only)
                                    .secure(cookie_config.secure)
                                    .same_site(cookie_config.same_site)
                                    .finish();

                            // Update token cookie with a new token
                            match resp.response_mut().add_cookie(&new_token_cookie) {
                                Ok(_) => {}
                                Err(e) => {
                                    let res = HttpResponse::InternalServerError()
                                        .body("Failed to set a new csrf token");

                                    error!(
                                        "unable to set a token cookie in csrf response: {:?}",
                                        e
                                    );
                                    return Poll::Ready(Ok(resp
                                        .into_response(res)
                                        .map_into_boxed_body()
                                        .map_into_right_body()));
                                }
                            }
                        }
                    }
                }

                Poll::Ready(Ok(resp.map_into_left_body()))
            }
            Err(err) => Poll::Ready(Err(err)),
        }
    }
}

#[derive(Clone)]
pub struct CsrfToken(pub String);

impl FromRequest for CsrfToken {
    type Error = Error;
    type Future = Ready<Result<Self, Self::Error>>;

    fn from_request(req: &HttpRequest, _: &mut actix_web::dev::Payload) -> Self::Future {
        match req.extensions().get::<CsrfToken>() {
            Some(token) => ok(token.clone()),
            None => err(actix_web::error::ErrorInternalServerError(
                "CSRF middleware is not configured",
            )),
        }
    }
}

pub fn generate_random_token() -> String {
    let mut buf = [0u8; TOKEN_LEN];
    rand::rng().fill_bytes(&mut buf);
    URL_SAFE_NO_PAD.encode(buf)
}

pub fn eq_tokens(token_a: &[u8], token_b: &[u8]) -> bool {
    token_a.ct_eq(token_b).unwrap_u8() == 1
}

pub fn generate_hmac_token(session_id: &str, secret: &[u8]) -> String {
    let tok = generate_random_token();
    let mut mac = HmacSha256::new_from_slice(secret).expect("HMAC can take key of any size");
    let message = format!("{}!{}", session_id, tok);
    mac.update(message.as_bytes());

    let hmac_hex = hex::encode(mac.finalize().into_bytes());
    format!("{}.{}", hmac_hex, tok)
}

pub fn validate_hmac_token(session_id: &str, token: &[u8], secret: &[u8]) -> Result<bool, Error> {
    let token_str = str::from_utf8(token)?;
    let parts: Vec<&str> = token_str.split('.').collect();
    if parts.len() != 2 {
        return Ok(false);
    }
    let (hmac_hex, csrf_token) = (parts[0], parts[1]);

    let mut mac = Hmac::<Sha256>::new_from_slice(secret)
        .map_err(actix_web::error::ErrorInternalServerError)?;
    let message = format!("{}!{}", session_id, csrf_token);
    mac.update(message.as_bytes());
    let expected_hmac = mac.finalize().into_bytes();

    let hmac_bytes = hex::decode(hmac_hex).map_err(actix_web::error::ErrorInternalServerError)?;

    Ok(eq_tokens(&expected_hmac, &hmac_bytes))
}

#[cfg(test)]
mod tests {
    use super::*;

    const SESSION_ID: &str = "test";
    const SECRET: &str = "secret";

    #[test]
    fn test_generate_and_validate_hmac_token() {
        let token = generate_hmac_token(SESSION_ID, SECRET.as_bytes());
        let res = validate_hmac_token(SESSION_ID, token.as_bytes(), SECRET.as_bytes());
        assert!(res.unwrap());
    }

    #[test]
    fn test_handle_invalid_hmac_token() {
        let token = generate_hmac_token(SESSION_ID, SECRET.as_bytes());
        let res = validate_hmac_token(SESSION_ID, token.as_bytes(), SECRET.as_bytes());
        assert!(res.unwrap());
    }
}
